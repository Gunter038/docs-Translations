- - -
sidebar_label : Рівень доступності даних Celestia
- - -

# Життєвий цикл транзакції програми Celestia

Користувачі роблять запит до програми Celestia, щоб зробити дані доступними надсилаючи транзакції `PayForData`. Кожна така транзакція складається з ідентифікації відправника, даних, які будуть доступні, які також називаються повідомленням, розміру даних, ідентифікатору простору імен і підпису. Кожен виробник блоків об’єднує кілька транзакцій `PayForData` в один блок.

Перш ніж запропонувати блок, виробник передає його до кінцевого автомату через ABCI++, де кожна транзакція `PayForData` розбивається на повідомлення простору імен (позначене `Msg` на малюнку нижче), тобто дані разом з ідентифікатором простору імен і виконуваною транзакцією (позначеною `e-Tx` на малюнку нижче), яка не містить даних, але лише зобов’язання, яке можна використати пізніше, щоб довести, що дані дійсно були доступні.

Таким чином, дані блоку складаються з даних, розділених на простори імен, і виконуваних транзакцій. Зверніть увагу, що тільки ці транзакції виконуються кінцевим автоматом Celestia як тільки блок буде зафіксовано.

![Життєвий цикл транзакції програми Celestia](/img/concepts/tx-lifecycle.png)

Далі виробник блоку додає до заголовка блоку зобов’язання щодо даних блоку. Як описано [тут](./data-availability-layer.md#fraud-proofs-of-incorrectly-extended-data), зобов’язанням є корінь Меркла з 4k проміжних коренів Меркла (тобто по одному для кожного рядка та стовпця розширеної матриці). Щоб обчислити це зобов’язання, виробник блоку виконує такі операції:

- Він розділяє виконувані транзакції та дані простору імен на спільні частки. Кожна частка складається з деяких байтів, попередньо визначених ідентифікатором простору імен. З цією метою виконувані операції пов'язані із зарезервованим простором імен.
- Він розбудовує ці частки на квадратну матрицю (по рядках). Зверніть увагу, що частки доповнюються до наступного ступеня двійки. Квадрат результату розміром k × k називають вихідними даними.
- Він розширює оригінальні дані до квадратної матриці 2k × 2k за допомогою двовимірної схеми кодування Ріда-Соломона, описаної вище. Розширені частки (тобто з помилковими даними) пов’язані з іншим зарезервованим простором імен.
- Він обчислює зобов’язання для кожного рядка та стовпця розширеної матриці, використовуючи вищезгадані NMT.

Таким чином, зобов’язання даних блоку є коренем дерева Merkle з листям і корінням лісу піддерев Merkle з простором імен, по одному для кожного рядка та стовпця розширеної матриці.

## Перевірка наявності даних

![DA мережа](/img/concepts/consensus-da.png)

Щоб покращити підключення, нода Celestia доповнює програму Celestia з окремою мережею libp2p, тобто так званою _ DA network_, яка обслуговує запити DAS.

Легкі вузли підключаються до вузла Celestia в мережі DA, щоб слухати розширені заголовки блоків (тобто заголовки блоків разом із відповідними метаданими DA, такими як проміжні корені Merkle 4k), і виконувати DAS над отриманими заголовками (тобто запитувати випадкові фрагменти даних).

Зауважте, що, попри те, що це рекомендовано, виконання DAS є необов’язковим — легкі вузли можуть просто повірити, що дані, які відповідають зобов’язанням у заголовках блоків, дійсно були доступні Celestia DA рівнем. Крім того, легкі вузли також можуть надсилати транзакції в програму Celestia, тобто транзакції `PayForData`.

Під час виконання DAS для заголовка блоку кожен легкий вузол запитує вузли Celestia щодо ряду випадкових фрагментів даних із розширеної матриці та відповідних доказів Merkle. Якщо всі запити виконані успішно, то легкий вузол приймає заголовок блоку як дійсний (з точки зору DA).

Якщо принаймні один із запитів зазнає невдачі (тобто фрагмент даних не отримано, або доказ Merkle недійсний), тоді легкий вузол відхиляє заголовок блоку та повторює спробу пізніше. Повторний розгляд необхідний, щоб мати справу з помилковими негативними результатами, тобто відхиленням заголовків блоку, хоча дані блоку доступні. Це може статися, наприклад, через перевантаження мережі.

Альтернативно, легкі вузли можуть приймати заголовок блоку, хоча дані недоступні, тобто _false positive_. Це можливо, оскільки властивість надійності (тобто, якщо чесний легкий вузол приймає блок як доступний, то принаймні один чесний повний вузол зрештою матиме всі дані блоку) імовірнісне гарантовано (щоб дізнатися більше, подивіться на < [original paper](https://arxiv.org/abs/1809.09044)).

Завдяки точному налаштуванню параметрів Celestia (наприклад, кількості фрагментів даних, що відбираються кожним легким вузлом), ймовірність помилкових спрацьовувань може бути достатньо зменшена, щоб виробники блоків не мали стимулу приховувати дані блоків.
