- - -
sidebar_label : Рівень доступності даних Celestia
- - -

# Рівень доступності даних Celestia

Celestia - це рівень доступності даних (DA), який забезпечує масштабоване рішення [проблеми доступності даних](https://coinmarketcap.com/alexandria/article/what-is-data-availability). У зв'язку з бездозвільною природою блокчейн мереж, рівень DA повинен забезпечувати механізм для рівнів виконання та розрахунків для перевірки з мінімізованою довірою, чи дані транзакцій дійсно доступні.

Дві ключові особливості шару DA Celestia - це [вибірка доступності даних](https://blog.celestia.org/celestia-mvp-release-data-availability-sampling-light-clients/) (DAS) та [Дерева Меркла, розміщені в просторі імен](https://github.com/celestiaorg/nmt) (NMT). Обидві функції є новими рішеннями для масштабування блокчейну: DAS дозволяє легким вузлам перевіряти наявність даних без необхідності завантажувати весь блок; NMT дозволяє рівням виконання і розрахунків на Celestia завантажувати транзакції, які мають відношення тільки до них.

## Вибірка Доступності Даних (DAS)

В цілому, легкі вузли завантажують тільки заголовки блоків, які містять зобов'язання (тобто корені Меркла) даних блоку (тобто список транзакцій).

Щоб зробити DAS можливим, Celestia використовує 2-вимірну схему кодування Ріда-Соломона для кодування блокових даних: кожен блок даних розбивається на k × k фрагментів, розташованих у матриці k × k, і розширюється за допомогою парності даних у розширену матрицю 2k × 2k шляхом багаторазового застосування кодування Ріда-Соломона.

Потім для рядків і стовпців розширеної матриці обчислюються 4k окремих коренів Меркла; корінь Меркла з цих коренів Меркла використовується як зобов'язання даних блоку в заголовку блоку.

![2D Reed-Soloman (RS) Encoding](/img/concepts/reed-solomon-encoding.png)

Щоб переконатися, що дані доступні, легкі вузли Celestia беруть вибірку з фрагментів даних 2k × 2k.

Кожен легкий вузол випадковим чином вибирає набір унікальних координат у розширеній матриці і запитує повні вузли для отримання фрагментів даних і відповідних доведень Меркла за цими координатами. Якщо легкі вузли отримують дійсну відповідь на кожен запит вибірки, то існує [високоймовірна гарантія](https://github.com/celestiaorg/celestia-node/issues/805#issuecomment-1150081075) що дані всього блоку доступні.

Крім того, кожен отриманий фрагмент даних з коректним доказом Меркла передається в мережу. В результаті, поки легкі вузли Селестії вибирають разом достатньо блоків даних (тобто, принаймні, k × k унікальних блоків), повний блок може бути відновлений чесними повними вузлами.

Для отримання більш детальної інформації про DAS ознайомтеся з [оригінальним документом](https://arxiv.org/abs/1809.09044).

### Масштабованість

DAS дозволяє Селестії масштабувати шар DA. DAS може виконуватися за допомогою обмежених в ресурсах легких вузлів, оскільки кожен легкий вузол відбирає лише невелику частину даних блоку. Чим більше легких вузлів в мережі, тим більше даних вони можуть колективно завантажувати і зберігати.

Це означає, що збільшення кількості легких вузлів, які виконують DAS, дозволяє створювати більші блоки (тобто з більшою кількістю транзакцій), водночас зберігаючи DAS можливим для легких вузлів з обмеженими ресурсами. Однак, щоб перевірити заголовки блоків, легкі вузли Celestia повинні завантажити проміжні корені Merkle 4k.

Для блоку даних розміром n байт це означає, що кожен легкий вузол повинен завантажити O(n) байт. Тому будь-яке поліпшення пропускної здатності легких вузлів Celestia має квадратичний ефект на пропускну здатність DA-шару Celestia.

### Докази шахрайства щодо неправильно розширених даних

Вимога завантаження 4k проміжних коренів Меркла є наслідком використання двовимірної схеми кодування Ріда-Соломона. Альтернативно, DAS може бути розроблена зі стандартним (тобто, одновимірним) кодуванням Ріда-Соломона, де вихідні дані розбиваються на k частин і доповнюються k додатковими k додатковими блоками даних парності. Оскільки зобов'язання блочних даних - це корінь Меркла з 2k отриманих блоків даних, легким вузлам більше не потрібно завантажувати O(n) байт для перевірки заголовків блоків.

Недоліком стандартного кодування Ріда-Соломона є боротьба зі зловмисними виробниками блоків, які некоректно генерують розширені дані.

Це можливо, оскільки __Celestia не потребує чесності більшості консенсусу (тобто виробників блоків), щоб гарантувати доступність даних.__Таким чином, якщо розширені дані недійсні, вихідні дані можуть бути невідновленими, навіть якщо легкі вузли відбирають достатню кількість унікальних фрагментів (тобто принаймні k для стандартного кодування та k × k для 2-вимірного кодування).

Як рішення, _Докази шахрайства некоректно згенерованих розширених даних_ дозволяють легким вузлам відкидати блоки з недійсними розширеними даними. Такі докази вимагають реконструкції кодування та перевірки невідповідності. При стандартному кодуванні Ріда-Соломона це тягне за собою завантаження вихідних даних, тобто O(n) байт. На відміну від цього, при двовимірному кодуванні Ріда-Соломона потрібно лише O(n) байт оскільки достатньо перевірити лише один рядок або один стовпець розширеної матриці.

## Просторові дерева Меркла (NMT)

Celestia розділяє дані блоку на кілька просторів імен, по одному для кожного додатку (наприклад, роллапу) за допомогою шару DA. В результаті, кожен додаток повинен завантажувати тільки свої дані й може ігнорувати дані інших додатків.

Для того, щоб це працювало, рівень DA повинен мати можливість довести, що надані дані є повними, тобто повернуті всі дані для даного простору імен. З цією метою Celestia використовує іменовані дерева Меркла (NMT).

NMT - це дерево Меркла, листя якого впорядковано за ідентифікаторами простору імен та хеш-функцією, модифікованою таким чином, що кожен вузол дерева містити діапазон просторів імен всіх своїх нащадків. На наступному малюнку показано приклад NMT з висотою три (тобто вісім блоків даних). Дані розділені на три простори імен.

![Namespaced Merkle Tree](/img/concepts/nmt.png)

Коли програма запитує дані для простору імен 2, рівень DA має надати блоки даних `D3`, `D4`, `D5` і `D6 ` і вузли `N2`, `N8` і `N7` як доказ (зверніть увагу, що програма вже має корінь `N14` із заголовка блоку).

В результаті додаток має можливість перевірити, що надані дані є частиною даних блоку. Крім того, програма може перевірити, що всі дані для простору імен 2 були надані. Якщо рівень DA надає, наприклад, тільки фрагменти даних `D4` і `D5`, він також повинен надати вузли `N12` і `N11` як докази. Однак програма може визначити, що дані неповні, перевіривши діапазон простору імен двох вузлів, тобто обидва `N12` і `N11` мають нащадкову частину простору імен 2.

For more details on NMTs, take a look at the [original paper](https://arxiv.org/abs/1905.09274).

## Building a PoS Blockchain for DA

### Providing Data Availability

The Celestia DA layer consists of a PoS blockchain. Celestia is dubbing this blockchain as the [Celestia App](https://github.com/celestiaorg/celestia-app), an application that provides transactions to facilitate the DA layer and is built using [Cosmos SDK](https://docs.cosmos.network/v0.44/). The following figure shows the main components of Celestia App.

![Main components of Celestia App](/img/concepts/celestia-app.png)

Celestia App is built on top of [Celestia Core](https://github.com/celestiaorg/celestia-core), a modified version of the [Tendermint consensus algorithm](https://arxiv.org/abs/1807.04938). Among the more important changes to vanilla Tendermint, Celestia Core:

- Enables the erasure coding of block data (using the 2-dimensional Reed-Solomon encoding scheme).
- Replaces the regular Merkle tree used by Tendermint to store block data with a [Namespaced Merkle tree](https://github.com/celestiaorg/nmt) that enables the above layers (i.e., execution and settlement) to only download the needed data (for more details, see the section below describing use cases).

For more details on the changes to Tendermint, take a look at the [ADRs](https://github.com/celestiaorg/celestia-core/tree/v0.34.x-celestia/docs/celestia-architecture). Notice that Celestia Core nodes are still using the Tendermint p2p network.

Similarly to Tendermint, Celestia Core is connected to the application layer (i.e., the state machine) by [ABCI++](https://github.com/tendermint/tendermint/tree/master/spec/abci%2B%2B), a major evolution of [ABCI](https://github.com/tendermint/tendermint/tree/master/spec/abci) (Application Blockchain Interface).

The Celestia App state machine is necessary to execute the PoS logic and to enable the governance of the DA layer.

However, the Celestia App is data-agnostic -- the state machine neither validates nor stores the data that is made available by the Celestia App.
