- - -
sidebar_label : Слой доступности данных Celestia
- - -

# Слой доступности данных Celestia

Celestia - это слой доступности данных (DA), который обеспечивает масштабируемое решение проблемы [ доступности данных](https://coinmarketcap.com/alexandria/article/what-is-data-availability). В связи с неразрешимой природой блокчейн сетей, слой DA должен обеспечить механизм для уровней исполнения и расчетов, позволяющий проверять с минимальным уровнем доверия, действительно ли данные транзакции доступны.

Двумя ключевыми особенностями уровня DA в Celestia являются [выборка доступности данных](https://blog.celestia.org/celestia-mvp-release-data-availability-sampling-light-clients/) (DAS) и [ деревья Меркла с распределением имен](https://github.com/celestiaorg/nmt) (NMTs). Обе функции представляют собой новые решения для масштабирования блокчейна: DAS позволяет легким узлам проверять доступность данных без необходимости загрузки всего блока; NMT позволяют слоям исполнения и расчетов на Celestia загружать транзакции которые относятся только к ним.

## Выборка доступности данных (DAS)

В общем, легкие узлы загружают только заголовки блоков, которые содержат коммиты (т.е. корни Меркла) данных блока (т.е. список транзакций).

Чтобы сделать DAS возможным, Celestia использует двухмерную схему Reed-Solomon кодирования для кодирования данных блока: каждый блок данных разделяется на k × k, в матрице k × k, и расширяется с чётностью данных в 2k × 2k расширенную матрицы путем многократного использования кодирования Reed-Solomon.

Затем вычисляются 4k отдельных корней Меркла для строк и столбцов расширенной матрицы; корень Меркла из этих корней Меркла используется в качестве обязательства данных блока в заголовке блока.

![2D-кодирование Рида-Соломана (RS)](/img/concepts/reed-solomon-encoding.png)

Чтобы убедиться в наличии данных, легкие узлы Celestia делают выборку фрагмента данных размером 2k × 2k.

Каждый легкий узел случайным образом выбирает набор уникальных координат в расширенной матрице и запрашивает полные узлы для получения блоков данных и соответствующие доказательства Меркла в этих координатах. Если легкие узлы получают правильный ответ на каждый запрос выборки, то с [высокой долей вероятности](https://github.com/celestiaorg/celestia-node/issues/805#issuecomment-1150081075) данные всего блока доступны.

Кроме того, каждый полученный фрагмент данных с правильным доказательством Меркла передается в сеть. В результате до тех пор, пока легкие узлы Celestia собирают вместе достаточное количество блоков данных (т.е., по крайней мере, k × k уникальных блоков), полный блок может быть восстановлен честными полными узлами.

Для получения более подробной информации о DAS ознакомьтесь с [оригинальной статьей](https://arxiv.org/abs/1809.09044).

### Масштабирование

DAS позволяет Celestia масштабировать слой DA. DAS может выполняться с помощью ограниченных ресурсов легких узлов, поскольку каждый легкий узел производит только небольшую часть данных блока. Чем больше легких узлов есть в сети, тем больше данных, которые они могут загрузить и хранить.

Это означает, что увеличение числа легких узлов, выполняющих DAS, позволяет формировать большие блоки (например, с большим количеством транзакций), но при этом DAS может быть использована для легких узлов ограниченного ресурса. Однако для того, чтобы проверить заголовки блоков, легким узлам Celestia необходимо загрузить промежуточные 4k корни Меркла.

Для размера блока данных n байт это означает, что каждый легкий узел должен загрузить O(n) байт. Таким образом, любое улучшение пропускной способности легких узлов Celestia имеет квадратичный эффект на пропускную способность DA слоя.

### Доказательства мошенничества с неверно распространенными данными

Требование загрузки промежуточных 4k корней Меркла является следствием использования двумерной схемы кодирования Рида-Соломона. В качестве альтернативы, DAS может быть разработана со стандартным (т.е. одномерным) кодированием Рида-Соломона, где исходные данные разбиваются на k фрагментов и увеличиваются на k дополнительных фрагментов данных о четности. Поскольку обязательство данных блока является корнем Меркла из 2k результирующих блоков данных, легким узлам больше не нужно загружать O(n) байт для проверки заголовков блоков.

Недостатком стандартного кодирования Рида-Соломона является работа со злонамеренными производителями блоков, которые неправильно генерируют увеличенные данные.

Это возможно, поскольку __Celestia не требует, чтобы большинство участников консенсуса (т.е. производителей блоков) были честными, чтобы гарантировать доступность данных.__ Таким образом, если увеличенные данные недействительны, исходные данные могут не подлежать восстановлению, даже если легкие узлы производят выборку достаточного количества уникальных фрагментов (т.е., по крайней мере, k для стандартного кодирования и k × k для двумерного кодирования).

В качестве решения _Доказательства мошенничества в отношении неверно сгенерированных расширенных данных_ позволяют легким узлам отклонять блоки с недействительными расширенными данными. Такие доказательства требуют восстановления кодировки и проверки несоответствия. При стандартном кодировании Рида-Соломона это требует загрузки исходных данных, т.е. O(n) байт. Напротив, при двумерном кодировании Рида-Соломона требуется только O(n ) байт, поскольку достаточно проверить только одну строку или один столбец расширенной матрицы.

## Деревья Меркла с пространством имен (NMT)

Celestia разделяет данные блока на несколько пространств имен, по одному для каждого приложения (например, rollup), использующего слой DA. В результате каждое приложение должно загружать только свои собственные данные и может игнорировать данные других приложений.

Для того чтобы это работало, слой DA должен быть в состоянии доказать, что предоставленные данные являются завершёнными, т.е. все предоставленные данные для пространства имён возвращены. Для этого Celestia использует Namespaced Merkle Trees (NMTs).

NMT - это дерево Меркла, листья которого упорядочены идентификаторами пространства имен, а хэш-функция изменена таким образом, что каждый узел дерева включает диапазон пространства имен всех своих потомков. На следующем рисунке показан пример NMT с высотой три (т.е. восемь блоков данных). Данные разделены на три пространства имен.

![Дерево Меркла с пространством имен](/img/concepts/nmt.png)

Когда приложение запрашивает данные для пространства имен 2, слой DA должен предоставить фрагменты данных `D3`, `D4`, `D5` и `D6` и узлы `N2`, `N8` и `N7` в качестве доказательства (обратите внимание, что приложение уже имеет корень `N14` из заголовка блока).

В результате приложение может проверить, являются ли предоставленные данные частью данных блока. Кроме того, приложение может проверить, что были предоставлены все данные для пространства имен 2. Если DA слой, к примеру, предоставляет только фрагменты данных `D4` и `D5`, он должен также предоставлять узлы `N12` и `N11` в качестве доказательств. Однако приложение может определить, что данные неполные, проверив диапазон пространств имен двух узлов, т.е. и `N12`, и `N11` имеют потомков, входящих в пространство имен 2.

Для получения более подробной информации о DAS ознакомьтесь с [оригинальной статьей](https://arxiv.org/abs/1905.09274).

## Создание блокчейна PoS для DA

### Обеспечение доступности данных

Слой Celestia DA состоит из блокчейна PoS. Celestia дублирует этот блокчейн как [приложение Celestia](https://github.com/celestiaorg/celestia-app), приложение, которое предоставляет транзакции для облегчения DA слоя и построено с помощью [Cosmos SDK](https://docs.cosmos.network/v0.44/). На рисунке показаны основные компоненты приложения Celestia.

![Основные компоненты приложения Celestia](/img/concepts/celestia-app.png)

Приложение Celestia построено на базе [Celestia Core](https://github.com/celestiaorg/celestia-core), модифицированной версии алгоритма консенсуса [Tendermint](https://arxiv.org/abs/1807.04938). Среди наиболее важных изменений классического Tendermint - Celestia Core:

- Включает стирающий код данных блока (с использованием двумерной схемы кодирования Рида-Соломона).
- Заменяет обычное дерево Меркла, используемое Tendermint для хранения блочных данных, на [ Дерево Меркла с пространством имен](https://github.com/celestiaorg/nmt), которое позволяет вышележащие слоям (т.е. исполнение и расчеты) загружать только необходимые данные (подробнее см. раздел ниже, описывающий сценарии использования).

Для получения дополнительной информации об изменениях в Tendermint, ознакомьтесь с [ADRs](https://github.com/celestiaorg/celestia-core/tree/v0.34.x-celestia/docs/celestia-architecture). Обратите внимание, что узлы Celestia Core всё ещё используют p2p сеть Tendermint.

Аналогично Tendermint, Celestia Core подключается к прикладному слою (то есть, конечный автомат) посредством [ABCI++](https://github.com/tendermint/tendermint/tree/master/spec/abci%2B%2B), значительное развитие [ABCI](https://github.com/tendermint/tendermint/tree/master/spec/abci) (интерфейс приложений блокчейна).

Конечный автомат приложения Celestia необходим для выполнения логики PoS и для управления слоем DA.

Однако приложение Celestia не зависит от данных — конечный автомат не проверяет и не сохраняет данные, которые предоставляются приложением Celestia.
