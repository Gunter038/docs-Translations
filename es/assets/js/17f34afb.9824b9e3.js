"use strict";(self.webpackChunkcelestia_docs=self.webpackChunkcelestia_docs||[]).push([[1808],{3905:function(e,a,n){n.d(a,{Zo:function(){return u},kt:function(){return m}});var t=n(7294);function o(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function s(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){o(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function i(e,a){if(null==e)return{};var n,t,o=function(e,a){if(null==e)return{};var n,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(o[n]=e[n]);return o}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=t.createContext({}),l=function(e){var a=t.useContext(c),n=a;return e&&(n="function"==typeof e?e(a):s(s({},a),e)),n},u=function(e){var a=l(e.components);return t.createElement(c.Provider,{value:a},e.children)},p={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},d=t.forwardRef((function(e,a){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=l(n),m=o,f=d["".concat(c,".").concat(m)]||d[m]||p[m]||r;return n?t.createElement(f,s(s({ref:a},u),{},{components:n})):t.createElement(f,s({ref:a},u))}));function m(e,a){var n=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=d;var i={};for(var c in a)hasOwnProperty.call(a,c)&&(i[c]=a[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<r;l++)s[l]=n[l];return t.createElement.apply(null,s)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},573:function(e,a,n){n.r(a),n.d(a,{assets:function(){return u},contentTitle:function(){return c},default:function(){return m},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return p}});var t=n(7462),o=n(3366),r=(n(7294),n(3905)),s=["components"],i={},c=void 0,l={unversionedId:"concepts/how-celestia-works/monolithic-vs-modular",id:"concepts/how-celestia-works/monolithic-vs-modular",title:"monolithic-vs-modular",description:"- - -",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/concepts/how-celestia-works/monolithic-vs-modular.md",sourceDirName:"concepts/how-celestia-works",slug:"/concepts/how-celestia-works/monolithic-vs-modular",permalink:"/es/concepts/how-celestia-works/monolithic-vs-modular",draft:!1,editUrl:"https://github.com/celestiaorg/docs/tree/main/docs/concepts/how-celestia-works/monolithic-vs-modular.md",tags:[],version:"current",frontMatter:{},sidebar:"concepts",previous:{title:"Introducci\xf3n",permalink:"/es/concepts/how-celestia-works/introduction"},next:{title:"data-availability-layer",permalink:"/es/concepts/how-celestia-works/data-availability-layer"}},u={},p=[],d={toc:p};function m(e){var a=e.components,i=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,t.Z)({},d,i,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("hr",null),(0,r.kt)("p",null,"sidebar_label : Monol\xedticas vs. Bloques Modulares"),(0,r.kt)("hr",null),(0,r.kt)("h1",{id:"monol\xedticas-vs-blockchains-modulares"},"Monol\xedticas vs. Blockchains Modulares"),(0,r.kt)("p",null,"Las Blockchains requieren ",(0,r.kt)("a",{parentName:"p",href:"https://dl.acm.org/doi/abs/10.1145/98163.98167"},"m\xe1quinas de estado replicadas"),": los nodos en una red distribuida sin permiso aplican una secuencia ordenada de transacciones deterministas a un estado inicial resultando en un estado com\xfan final. Esto significa que las blockchains requieren las siguientes cuatro funciones:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Ejecuci\xf3n")," implica ejecutar transacciones que actualizan el estado correctamente. Por lo tanto, la ejecuci\xf3n debe asegurarse de que solo se ejecutan transacciones v\xe1lidas, por ejemplo:   transacciones que resultan en transiciones autom\xe1ticas de estado v\xe1lidas."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"El Acuerdo")," entra\xf1a un entorno para las capas de ejecuci\xf3n para verificar pruebas, resolver disputas de fraude y puente entre otras capas de ejecuci\xf3n."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"El Consenso")," implica aceptar el orden de las transacciones."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"La Disponibilidad de Datos")," (DA) implica que los datos de la transacci\xf3n est\xe9n disponibles. Ten en cuenta que la ejecuci\xf3n, la soluci\xf3n y el consenso requieren DA.")),(0,r.kt)("p",null,"Las blockchains tradicionales, es decir, ",(0,r.kt)("em",{parentName:"p"},"monol\xedticas blockchains"),", implementan las cuatro funciones juntas en una sola capa de consenso base. El problema con las blockchains monol\xedticas es que la capa de consenso debe realizar muchas tareas diferentes y no pueden ser optimizadas en solo una de estas funciones. Como resultado, el paradigma monol\xedtico limita el recorrido del sistema."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Monol\xedticas VS Modulares",src:n(5847).Z,width:"1428",height:"578"})),(0,r.kt)("p",null,"Como soluci\xf3n, las blockchains modulares desacoplan estas funciones entre capas especializadas como parte de una pila modular. Debido a la flexibilidad que proporciona la especializaci\xf3n, hay muchas posibilidades en las que se puede organizar esa pila. Por ejemplo, uno de estos arreglos es la separaci\xf3n de las cuatro funciones en tres capas especializadas."),(0,r.kt)("p",null,"La capa base consiste en DA y consenso y, por lo tanto, se refiere a como la capa de Consenso y DA (o por brevedad, la capa DA), mientras que tanto el establecimiento y la ejecuci\xf3n se mueven en la parte superior de sus propias capas. Como resultado, cada capa se puede especializar para realizar \xf3ptimamente s\xf3lo su funci\xf3n y, por lo tanto, aumentar el rendimiento del sistema. Adem\xe1s, este paradigm modular permite m\xfaltiples capas de ejecuci\xf3n, por ejemplo, ",(0,r.kt)("a",{parentName:"p",href:"https://vitalik.ca/general/2021/01/05/rollup.html"},"rollups"),"para usar la misma capa de consenso y DA."))}m.isMDXComponent=!0},5847:function(e,a,n){a.Z=n.p+"assets/images/monolithic-modular-d2ebbbc814c3338adf1cdd8b91eef221.png"}}]);