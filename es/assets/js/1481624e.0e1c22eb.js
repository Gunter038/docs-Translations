"use strict";(self.webpackChunkcelestia_docs=self.webpackChunkcelestia_docs||[]).push([[3139],{3905:function(e,n,r){r.d(n,{Zo:function(){return d},kt:function(){return p}});var t=r(7294);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function s(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function a(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?s(Object(r),!0).forEach((function(n){o(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function i(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},s=Object.keys(e);for(t=0;t<s.length;t++)r=s[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(t=0;t<s.length;t++)r=s[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var u=t.createContext({}),l=function(e){var n=t.useContext(u),r=n;return e&&(r="function"==typeof e?e(n):a(a({},n),e)),r},d=function(e){var n=l(e.components);return t.createElement(u.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var r=e.components,o=e.mdxType,s=e.originalType,u=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=l(r),p=o,g=m["".concat(u,".").concat(p)]||m[p]||c[p]||s;return r?t.createElement(g,a(a({ref:n},d),{},{components:r})):t.createElement(g,a({ref:n},d))}));function p(e,n){var r=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=r.length,a=new Array(s);a[0]=m;var i={};for(var u in n)hasOwnProperty.call(n,u)&&(i[u]=n[u]);i.originalType=e,i.mdxType="string"==typeof e?e:o,a[1]=i;for(var l=2;l<s;l++)a[l]=r[l];return t.createElement.apply(null,a)}return t.createElement.apply(null,r)}m.displayName="MDXCreateElement"},9286:function(e,n,r){r.r(n),r.d(n,{assets:function(){return d},contentTitle:function(){return u},default:function(){return p},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return c}});var t=r(7462),o=r(3366),s=(r(7294),r(3905)),a=["components"],i={sidebar_label:"Keeper"},u="Funciones de Keeper",l={unversionedId:"developers/wordle-keeper",id:"developers/wordle-keeper",title:"Funciones de Keeper",description:"Ahora es el momento de implementar las funciones de Keeper para cada mensaje. De los documentos Cosmos-SDK, Keeper se define como lo siguiente:",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/developers/wordle-keeper.md",sourceDirName:"developers",slug:"/developers/wordle-keeper",permalink:"/es/developers/wordle-keeper",draft:!1,editUrl:"https://github.com/celestiaorg/docs/tree/main/docs/developers/wordle-keeper.md",tags:[],version:"current",frontMatter:{sidebar_label:"Keeper"},sidebar:"developers",previous:{title:"Tipos",permalink:"/es/developers/wordle-types"},next:{title:"Ejecutar la cadena Wordle",permalink:"/es/developers/run-wordle"}},d={},c=[{value:"Funci\xf3n SubmitWordle",id:"funci\xf3n-submitwordle",level:2},{value:"Funci\xf3n SubmitGuess",id:"funci\xf3n-submitguess",level:2},{value:"Archivo Protobuf",id:"archivo-protobuf",level:2}],m={toc:c};function p(e){var n=e.components,r=(0,o.Z)(e,a);return(0,s.kt)("wrapper",(0,t.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"funciones-de-keeper"},"Funciones de Keeper"),(0,s.kt)("p",null,"Ahora es el momento de implementar las funciones de Keeper para cada mensaje. De los documentos Cosmos-SDK, ",(0,s.kt)("a",{parentName:"p",href:"https://docs.cosmos.network/master/building-modules/keeper.html"},"Keeper")," se define como lo siguiente:"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"El n\xfacleo principal de un m\xf3dulo Cosmos SDK es una pieza llamada keeper. Keeper maneja las interacciones con el almacenamiento, tiene referencias a otros mantenedores para interacciones entre m\xf3dulos y contiene la mayor\xeda de la funcionalidad principal de un m\xf3dulo.")),(0,s.kt)("p",null,"Keeper es una abstracci\xf3n en Cosmos que nos permite interactuar con el almac\xe9n Key-Value y cambiar el estado de la blockchain."),(0,s.kt)("p",null,"Aqu\xed, nos ayudar\xe1 a esbozar la l\xf3gica de cada mensaje que creamos."),(0,s.kt)("h2",{id:"funci\xf3n-submitwordle"},"Funci\xf3n SubmitWordle"),(0,s.kt)("p",null,"Comenzamos primero con la funci\xf3n ",(0,s.kt)("inlineCode",{parentName:"p"},"SubmitWordle"),"."),(0,s.kt)("p",null,"Abra el siguiente archivo: ",(0,s.kt)("inlineCode",{parentName:"p"},"x/wordle/keeper/msg_server_submit_wordle.go")),(0,s.kt)("p",null,"Dentro del siguiente bloque, a\xf1ade el siguiente c\xf3digo, el cual pasaremos en un rato:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},'package keeper\n\nimport (\n  "context"\n  "crypto/sha256"\n  "encoding/hex"\n  "github.com/YazzyYaz/wordle/x/wordle/types"\n  sdk "github.com/cosmos/cosmos-sdk/types"\n  sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"\n  "time"\n  "unicode"\n)\n\nfunc (k msgServer) SubmitWordle(goCtx context.Context, msg *types.MsgSubmitWordle) (*types.MsgSubmitWordleResponse, error) {\n  ctx := sdk.UnwrapSDKContext(goCtx)\n  // Check to See the Wordle is 5 letters\n  if len(msg.Word) != 5 {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Wordle Must Be A 5 Letter Word")\n  }\n  // Check to See Only Alphabets Are Passed for the Wordle\n  if !(IsLetter(msg.Word)) {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Wordle Must Only Consist Of Letters In The Alphabet")\n  }\n\n  // Use Current Day to Create The Index of the Newly-Submitted Wordle of the Day\n  currentTime := time.Now().Local()\n  var currentTimeBytes = []byte(currentTime.Format("2006-01-02"))\n  var currentTimeHash = sha256.Sum256(currentTimeBytes)\n  var currentTimeHashString = hex.EncodeToString(currentTimeHash[:])\n  // Hash The Newly-Submitted Wordle of the Day\n  var submittedSolutionHash = sha256.Sum256([]byte(msg.Word))\n  var submittedSolutionHashString = hex.EncodeToString(submittedSolutionHash[:])\n\n  var wordle = types.Wordle{\n    Index:     currentTimeHashString,\n    Word:      submittedSolutionHashString,\n    Submitter: msg.Creator,\n  }\n\n  // Try to Get Wordle From KV Store Using Current Day as Key\n  // This Helps ensure only one Wordle is submitted per day\n  _, isFound := k.GetWordle(ctx, currentTimeHashString)\n  if isFound {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Wordle of the Day is Already Submitted")\n  }\n  // Write Wordle to KV Store\n  k.SetWordle(ctx, wordle)\n  return &types.MsgSubmitWordleResponse{}, nil\n}\n\nfunc IsLetter(s string) bool {\n  for _, r := range s {\n    if !unicode.IsLetter(r) {\n      return false\n    }\n  }\n  return true\n}\n')),(0,s.kt)("p",null,"Aqu\xed en la funci\xf3n Keeper de ",(0,s.kt)("inlineCode",{parentName:"p"},"SubmitWordle"),", estamos haciendo algunas cosas:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Primero nos aseguramos de que una palabra enviada para la palabra del d\xeda tenga 5 letras de largo y solo use alfabetos. Eso significa que ning\xfan entero puede ser enviado en la cadena."),(0,s.kt)("li",{parentName:"ul"},"Entonces creamos un hash desde el d\xeda actual en el momento en que se envi\xf3 la Wordle. Establecemos este hash al \xedndice del tipo Wordle. Esta nos permite buscar cualquier suposici\xf3n para esta Wordle, lo cual pasaremos a continuaci\xf3n."),(0,s.kt)("li",{parentName:"ul"},"Entonces verificamos si el \xedndice para la fecha de hoy est\xe1 vac\xedo o no. Si no est\xe1 vac\xedo, esto significa que un Wordle ya ha sido enviado. Recuerda, solo se puede enviar una wordle por d\xeda. Todos los dem\xe1s tienen que adivinar la palabra presentada."),(0,s.kt)("li",{parentName:"ul"},"Tambi\xe9n tenemos una funci\xf3n de ayuda ah\xed para comprobar si una cadena s\xf3lo contiene caracteres de alfabeto.")),(0,s.kt)("h2",{id:"funci\xf3n-submitguess"},"Funci\xf3n SubmitGuess"),(0,s.kt)("p",null,"La siguiente funci\xf3n de Keeper que a\xf1adiremos es la siguiente: ",(0,s.kt)("inlineCode",{parentName:"p"},"x/wordle/keeper/msg_server_submit_guess.go")),(0,s.kt)("p",null,"Dentro del siguiente bloque, a\xf1ade el siguiente c\xf3digo, el cual pasaremos en un rato:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},'package keeper\n\nimport (\n  "context"\n  "crypto/sha256"\n  "encoding/hex"\n  "github.com/YazzyYaz/wordle/x/wordle/types"\n  sdk "github.com/cosmos/cosmos-sdk/types"\n  sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"\n  "strconv"\n  "time"\n  "github.com/tendermint/tendermint/crypto"\n)\n\nfunc (k msgServer) SubmitGuess(goCtx context.Context, msg *types.MsgSubmitGuess) (*types.MsgSubmitGuessResponse, error) {\n  ctx := sdk.UnwrapSDKContext(goCtx)\n  // Check Word is 5 Characters Long\n  if len(msg.Word) != 5 {\n    return nil, sdkerrors.Wrap(sdkerrors.ErrInvalidRequest, "Guess Must Be A 5 Letter Word!")\n  Wrap(sdkerrors.ErrInvalidRequest, "Guess Must Be A 5 Letter Word!")\n  }\n\n  // Check String Contains Alphabet Letters Only\n  if !(IsLetter(msg.Word)) {\n    return nil, sdkerrors.\n  Now().Local()\n  var currentTimeBytes = []byte(currentTime.Format("2006-01-02"))\n  var currentTimeHash = sha256.Sum256(currentTimeBytes)\n  var currentTimeHashString = hex. EncodeToString(currentTimeHash[:])\n  wordle, isFound := k. GetWordle(ctx, currentTimeHashString)\n  if !isFound {\n    return nil, sdkerrors. Wrap(sdkerrors.ErrInvalidRequest, "Wordle of The Day Hasn\'t Been Submitted Yet. \xa1Si\xe9ntete libre de enviar una!")\n  Feel Free to Submit One!")\n  }\n\n  // We Convert Current Day and Guesser to A Hash To Use As An Index For Today\'s Guesses For That Guesser\n  // That Way, A Person Can Guess 6 Times A Day For Each New Wordle Created\n  var currentTimeGuesserBytes = []byte(currentTime.Format("2006-01-02") + msg. Creator)\n  var currentTimeGuesserHash = sha256.Sum256(currentTimeGuesserBytes)\n  var currentTimeGuesserHashString = hex. EncodeToString(currentTimeGuesserHash[:])\n  // Hash The Guess To The Wordle\n  var submittedSolutionHash = sha256.Sum256([]byte(msg.Word))\n  var submittedSolutionHashString = hex. EncodeToString(submittedSolutionHash[:])\n\n  // Get the Latest Guess entry for this Submitter for the current Wordle of the Day\n  var count int\n  guess, isFound := k. GetGuess(ctx, currentTimeGuesserHashString)\n  if isFound {\n    // Check if Submitter Reached 6 Tries\n    if guess. Count == strconv. Itoa(6) {\n      return nil, sdkerrors. Wrap(sdkerrors.ErrInvalidRequest, "You Have Guessed The Maximum Amount of Times for The Day! Try Again Tomorrow With A New Wordle.")\n    }\n    currentCount, err := strconv. Vuelva a intentarlo ma\xf1ana con una nueva Wordle.")\n    Atoi(guess.Count)\n    if err != nil {\n      panic(err)\n    }\n    count = currentCount\n  } else {\n    // Initialize Count Value If No Entry Exists for this Submitter for Today\'s Wordle\n    count = 0\n  }\n  // Increment Guess Count\n  count += 1\n  var newGuess = types. Guess{\n    Index:     currentTimeGuesserHashString,\n    Submitter: msg. Creator,\n    Word:      submittedSolutionHashString,\n    Count:     strconv. Itoa(count),\n  }\n  // Remove Current Guess Entry to be Updated With New Entry\n  k. RemoveGuess(ctx, currentTimeGuesserHashString)\n  // Add New Guess Entry\n  k. SetGuess(ctx, newGuess)\n  // Setup Reward \n  reward := sdk. Coins{sdk.NewInt64Coin("WORDLE", 100)}\n  if !(wordle.Word == submittedSolutionHashString) {\n    return &types.MsgSubmitGuessResponse{Title: "Wrong Answer", Body: "Your Guess Was Wrong. Try Again"}, nil\n  } else {\n    // If Submitter Guesses Correctly\n    guesserAddress, _ := sdk. AccAddressFromBech32(msg.Creator)\n    moduleAcct := sdk. AccAddress(crypto.AddressHash([]byte(types.ModuleName)))\n    // Send Reward\n    k.bankKeeper.SendCoins(ctx, guesserAddress, moduleAcct, reward) \n    return &types.MsgSubmitGuessResponse{Title: "Correct", Body: "You Guessed The Wordle Correctly!"}, nil\n  }\n}\n')),(0,s.kt)("p",null,"En el c\xf3digo anterior, estamos haciendo las siguientes cosas:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Aqu\xed estamos volviendo a verificar la palabra para asegurarnos que son 5 caracteres y solo caracteres alfab\xe9ticos usados. que puede ser refactorizado en el futuro o comprobado dentro de los comandos CLI."),(0,s.kt)("li",{parentName:"ul"},"Entonces obtenemos la Wordle del d\xeda obteniendo la cadena hash de el d\xeda actual."),(0,s.kt)("li",{parentName:"ul"},"A continuaci\xf3n crearemos una cadena de hash del d\xeda actual y del remitente. Esto nos permite crear un tipo de Guess con un \xedndice que utiliza el d\xeda actual y la direcci\xf3n del env\xedo. Esto nos ayuda cuando nos enfrentamos a un nuevo d\xeda y una direcci\xf3n quiere adivinar la nueva palabra del d\xeda. La configuraci\xf3n del \xedndice asegura que pueden continuar adivinando una nueva palabra cada d\xeda hasta el m\xe1ximo de 6 intentos por d\xeda."),(0,s.kt)("li",{parentName:"ul"},"Luego verificamos si ese tipo de adivinaci\xf3n para el Enviador de la palabra de hoy lleg\xf3 a 6 cuentas. Si no lo ha hecho, incrementamos el recuento. Entonces comprobamos si la conjetura es correcta. Almacenamos el tipo de adivinaci\xf3n con el recuento actualizado al estado.")),(0,s.kt)("h2",{id:"archivo-protobuf"},"Archivo Protobuf"),(0,s.kt)("p",null,"  Para que esto funcione, es necesario modificar algunos archivos."),(0,s.kt)("p",null,"El primero es ",(0,s.kt)("inlineCode",{parentName:"p"},"proto/wordle/tx.proto"),"."),(0,s.kt)("p",null,"Dentro de este archivo, rellena el vac\xedo ",(0,s.kt)("inlineCode",{parentName:"p"},"MsgSubmitGuessResponse")," con el siguiente c\xf3digo:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},"message MsgSubmitGuessResponse {\n  string title = 1;\n  string body = 2;\n}\n")),(0,s.kt)("p",null,"El siguiente archivo es ",(0,s.kt)("inlineCode",{parentName:"p"},"x/wordle/types/expected_keepers.go")),(0,s.kt)("p",null,"Aqu\xed tenemos que a\xf1adir el m\xe9todo SendCoins a la interfaz de BankKeeper para poder enviar la recompensa al cliente correcto."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-go"},"type BankKeeper interface {\n  SendCoins(ctx sdk.Context, fromAddr sdk.AccAddress, toAddr sdk.AccAddress, amt sdk.Coins) error\n}\n")),(0,s.kt)("p",null,"\xa1Con eso, implementamos todas nuestras funciones de Keeper! Tiempo para compilar la blockchain y sacarla para una unidad de prueba."))}p.isMDXComponent=!0}}]);